##   W e i g h t s#macro(solveMC = SolveTools[Linear]):infolevel[solveMC] := infolevel[homrels]:weight := proc(a)  global `weight/tab`;  local aux;  if type (a,'numeric') then 0  elif type (a,`*`) then    convert(map(procname, convert(a,'list')), `+`)  elif type (a,`^`) then op(2,a)*procname(op(1,a))  elif assigned(`weight/tab`[a]) then `weight/tab`[a]  elif type (a,specfunc(anything,{'jet','pd','TD'})) then    procname(op(1,a)) - procname(op(2,a))  elif type(a,`+`) then    aux := map(procname, convert(a,'set'));    if nops(aux) = 1 then op(1,aux)    else lprint(`WARNING: nonhomogeneous`, aux, `apply multieq and solve`)    fi  fiend:assignweight := proc()  global `weight/tab`;  map(proc(e)    if type(e,`=`) then `weight/tab`[lhs(e)] := rhs(e)    else ERROR(`invalid argument`, e)    fi;     rhs(e)  end, [args])end:multieq := proc()  map(`multieq/1`, {args})end:`multieq/1` := proc(S::{set,list})  local i;    seq(S[i] - S[1], i = 2..nops(S))end:allmonomials := proc(n::integer, w::{posint,procedure,`@`})  local qs,prw,ws,q;  if n = 0 then RETURN(1) fi;  qs := [args[3..nargs]];   if nops(qs) = 0 then RETURN() fi;  if type(w,'posint') then prw := proc(q) w end    elif type(w,{'procedure',`@`}) then prw := w    else ERROR(`invalid second argument`, w) fi;     ws := map(prw, qs);   if not type(ws, list(posint)) then print(ws); ERROR(`nonpositive weights`) fi;  qs := remove(proc(q,n) evalb(prw(q) > n) end, qs, n);    # abandon variables too big  if nops(qs) = 0 then RETURN() fi;    seq(seq(p*q,  	p in [procname(n - prw(q), prw, op(listtail(qs, q)))]),   q in qs);end:    listtail := proc(qs, q)  local k;  member(q, qs, k);  qs[k..nops(qs)]end:allms := proc(n::integer, ps::{set,list})  # all ordered monomials  local qs,ws,q;  global weight;  if n = 0 then RETURN(1) fi;  qs := [op(ps)];   if nops(qs) = 0 then RETURN() fi;  ws := map(weight, qs);   if not type(ws, list(posint)) then print(ws); ERROR(`nonpositive weights`) fi;  qs := remove(proc(q,n) evalb(weight(q) > n) end, qs, n);    # abandon variables too big  if nops(qs) = 0 then RETURN() fi;    seq(seq(p*q,  	p in [procname(n - weight(q), listtail(qs, q))]),   q in qs);end:    allmms := proc(n::integer, ps::{set,list})  # all unordered monomials  local qs,ws,q;  global weight;  if n = 0 then RETURN(1) fi;  qs := [op(ps)];   if nops(qs) = 0 then RETURN() fi;  ws := map(weight, qs);   if not type(ws, list(posint)) then print(ws); ERROR(`nonpositive weights`) fi;  qs := remove(proc(q,n) evalb(weight(q) > n) end, qs, n);    # abandon variables too big  if nops(qs) = 0 then RETURN() fi;    seq(seq(p*q,  	p in [procname(n - weight(q), qs)]),   q in qs);end:    ms2poly := proc(a::symbol)  local es,as,i;  es := select(type, [args], `=`);   if nops(es) + 1 <> nargs then ERROR(`unrecognized arguments`) fi;  as := map(proc(e)      allproducts(lhs(e), rhs(e))    end, es);  assign(cat(a,'s') = seq(cat(a,i), i = 1..nops(as)));  add(cat(a,i)*as[i], i = 1..nops(as))end:allproducts := proc(as::list, bs::list)  local a,b;  seq(seq(a*b, a = as), b = bs)end:  unordpartitions := proc(n::integer)  # all unordered partitions into a sum  local q,p;  if n = 0 then RETURN([]) fi;  seq(seq([op(p),q], p = [procname(n - q)]), q = 1..n);end:partitions := proc(n::integer, a::{posint,range(posint)}, b::posint)  # all ordered partitions into a sum; summands not exceeding m;  local q,p;  if nargs < 2 then RETURN(procname(n,1,n))   elif nargs < 3 then RETURN(procname(n,lhs(a),rhs(a)))   fi;  if n = 0 then []  elif n < a then NULL  elif b < a then NULL  elif n = a then [a]  else    seq(seq([op(p), q], p = [procname(n - q, a, q)]), q = a..min(n,b))  fiend:uopartitions := proc(n::nonnegint)  if n = 0 then [[]]  else [seq(`uopartitions/1`(i, procname(n - i)), i = 1..n)]  fiend:`uopartitions/1` := proc(k::posint, ls::list(list))  seq([k, op(l)], l = ls)end:multisum := proc(n::nonnegint, m::nonnegint)  # all ordered m-tuples summing up to n  local i,j;  if n = 0 then [seq(0, i = 1..m)]   elif m = 1 then [n]   else    seq(op(map(proc(aux, p) [op(aux), p] end, [procname(i, m - 1)], n - i)), i = 0..n)  fiend:##   H o m o g e n e o u s   s o l u t i o n s## us = {X1 = [n1, {q11,q12,...}], X2 = [n2, {q21,q22,...}], ...}# third argument: Consthomsolve := proc(eqs::{list,set}, us::{list(`=`),set(`=`)}, Const::name) local u,j,ss,a,as,i,n,ans,aux,qs,Consts; ss := NULL; Consts := NULL; userinfo(4, homsolve, `entered with`, print("eqs" = eqs), print("us" = us)); for j to nops(us) do   u := lhs(us[j]);   as := [allms(op(rhs(us[j])))];	n := nops(as);   ss := ss, u = add(Const[j,i]*as[i], i = 1..n);   Consts := Consts, seq(Const[j,i], i = 1..n);   dependence(seq(Const[j,i](), i = 1..n)) od; userinfo(4, homsolve, `substitutions`, print(ss)); aux := eval(subs([ss], eqs));  qs := `union`(op(map(vars,aux)));  aux := map(collect, aux, qs, distributed, normal);  userinfo(4, homsolve, `equations after substitution`, print(aux)); aux := map(coeffs, aux, qs); userinfo(4, homsolve, `sliced equations`, print(aux)); aux := solve(aux, {Consts});  userinfo(4, homsolve, `solutions`, print(aux)); if aux = NULL then ans := FAIL else ans := eval(subs(aux, [ss])) fi; if {op(map(normal@eval, subs(ans, eqs)))} <> {0} then   print(op(map(normal@eval, subs(ans, eqs)))); ERROR(`solve failed`) fi;  op(ans)end:##   R a n k#Jmatrix := proc(Fs::{list,set}, qs::{list,set})  matrix([seq([seq(pd(F,q), F = Fs)], q = qs)])end: MCrank := proc(A::matrix, qs::{list,set}, N::posint)  local n,q,rsubs,rqs,rA,ans;  rsubs := proc(x) x = `random/1`() end;  ans := 0;  for n to N do     rqs := map(rsubs, qs); # print(rqs);    rA := traperror(map(eval, subs(rqs, op(A)))); # print(rA);    if rA = lasterror then # lprint(lasterror)    else ans := max(ans, linalg:-rank(rA));    fi;    ans  odend:substantialfunctions := proc(es::set(`=`), qs::{list,set}, N::posint)  local ans,fs,J,r,e,Je,re;  fs := map(rhs, es);  J := Jmatrix(fs, qs);  r := MCrank(J, qs, N);  print('rank' = r);  ans := NULL;  for e in es do    Je := Jmatrix(fs minus {rhs(e)}, qs);    re := MCrank(Je, qs, N);    if re < r then ans := ans, lhs(e) fi  od;  {ans}end:dependent2s := proc(es::set(`=`), ems::set(`=`), qs::{list,set}, N::posint)  local ans,n,fms,Jm,rm,J,r,i1,i2;  n := nops(es);  fms := map(rhs, ems);  Jm := Jmatrix(fms, qs);  rm := MCrank(Jm, qs, N);  print('rank' = rm);  ans := NULL;  for i1 to n do    for i2 to i1 - 1 do      J := Jmatrix(fms union {rhs(es[i1]),rhs(es[i2])}, qs);      r := MCrank(J, qs, N);      if r < rm + 2 then ans := ans, [lhs(es[i1]),lhs(es[i2])] fi    od  od;  {ans}end:dependent3s := proc(es::set(`=`), ems::set(`=`), qs::{list,set}, N::posint)  local ans,n,fms,Jm,rm,J,r,i1,i2,i3;  n := nops(es);  fms := map(rhs, ems);  Jm := Jmatrix(fms, qs);  rm := MCrank(Jm, qs, N);  print('rank' = rm);  ans := NULL;  for i1 to n do    for i2 to i1 - 1 do      for i3 to i2 - 1 do        J := Jmatrix(fms union {rhs(es[i1]),rhs(es[i2]),rhs(es[i3])}, qs);        r := MCrank(J, qs, N);        if r < rm + 3 then ans := ans, [lhs(es[i1]),lhs(es[i2]),lhs(es[i3])] fi      od    od  od;  {ans}end:##   H o m o g e n e o u s   r e l a t i o n s## es = {X1 = expr1, X2 = expr2, ...}testweights := proc(qs::{list,set})  local ans;  ans := remove(proc(q) type(weight(q), posint) end, qs);   if nops(ans) > 0 then ERROR(`No positive weight for`, op(ans)) fiend:homrels := proc(w::{posint,range(nonnegint)}, es::{set(`=`),list(`=`)}, us::{set,list})  local ms,ans,aux,cs,c1,ss,Ans,time0;  time0 := time();  Ans := NULL;  testweights(map(lhs, es));  if type(w,posint) then     ms := allms(w, map(lhs, es)); # allms(n, {X1,X2,...})  elif lhs(w) = 0 then    ms := 1, seq(allms(i, map(lhs, es)), i = 1..rhs(w))  else    ms := seq(allms(i, map(lhs, es)), i = w)  fi;  userinfo(2, homrels, nops([ms]), `monomials generated`, [time() - time0]);  ans := add(_c||i*ms[i], i = 1..nops([ms]));  userinfo(5, homrels, `answer prepared`, [time() - time0]);# aux := (numer@normal@subs)(es, ans):  aux := (numer@subs)(es, ans):  userinfo(3, homrels, `polynomial constructed, length =`, length(aux), [time() - time0]);  if nargs > 3 then aux := apply(args[4],aux) fi;  userinfo(3, homrels, `4th argument applied, length =`, length(aux), [time() - time0]);  aux := collect(aux, us, distributed, normal);  userinfo(5, homrels, `polynomial collected, length =`, length(aux), [time() - time0]);  aux := frontend(coeffs, [aux, convert(us,'list')], [{`*`,`+`,`^`,'list'}]);  userinfo(3, homrels, `coefficients splitted, number =`, nops({aux}), [time() - time0]);  aux := solve({aux}, {seq(_c||i, i = 1..nops([ms]))}); # print(aux);  cs := map(lhs, select(evalb, aux));  userinfo(1, homrels, nops(cs), `solutions obtained`, [time() - time0]); # print(cs);  for c1 in cs do    ss := map(proc(c,c1) if c = c1 then c = 1 else c = 0 fi end, cs, c1);    Ans := Ans, factor(subs(aux, ss, ans))  od;end:# method Monte Carlo #Â oldhomrelsMC := proc(w::{posint,range(nonnegint)}, es::{set(`=`),list(`=`)}, us::{set,list})  local ms,ans,anse,aux,`random/1`,random,M,N,n,rus,r,cs,c1,ss,Ans,time0;  global `homrels_redundancy`;  time0 := time();  if nargs > 3 then `random/1` := args[4] else `random/1` := rand(0..10) fi;   random := proc(x) x = `random/1`() end;  Ans := NULL;  testweights(map(lhs, es));  if type(w,posint) then     ms := allms(w, map(lhs, es)); # allms(n, {X1,X2,...})  elif lhs(w) = 0 then    ms := 1, seq(allms(i, map(lhs, es)), i = 1..rhs(w))  else    ms := seq(allms(i, map(lhs, es)), i = w)  fi;  M := nops([ms]);  userinfo(2, homrels, M, `monomials`, [time() - time0]);  ans := add(_c||i*ms[i], i = 1..nops([ms]));  anse := (eval@subs)(es, ans):  userinfo(3, homrels, `answer prepared`, [time() - time0]);  aux := NULL;  N := floor(`homrels_redundancy`*M);  for n to N do     rus := map(random, us);    r := traperror((eval@subs)(rus, anse)); # lprint(r);    if r = lasterror then # lprint(lasterror)    else aux := aux, r;      userinfo(3, homrels, `successful insertion`, n, [time() - time0]);    fi  od;  userinfo(2, homrels, nops({aux}), `equations`, [time() - time0]);  if auxs <> {} then    userinfo(1, homrels, op(auxs), `indeterminates`, [time() - time0])   fi;  aux := solveMC({aux}, {seq(_c||i, i = 1..nops([ms]))}); # print(aux);  cs := map(lhs, select(evalb, aux));  userinfo(1, homrels, nops(cs), `solutions`, [time() - time0]); # print(cs);  for c1 in cs do    ss := map(proc(c,c1) if c = c1 then c = 1 else c = 0 fi end, cs, c1);    Ans := Ans, factor(subs(aux, ss, ans))  od;end:#newhomrelsMC := proc(w::{posint,range(nonnegint)}, es::{set(`=`),list(`=`)}, us::{set,list})  local ms,ans,aux,auxs,`random/1`,random,M,N,n,rus,res,cs,c1,ss,Ans,time0;  global `homrels_redundancy`,`homrels_system`;  time0 := time();  if nargs > 3 then `random/1` := args[4] else `random/1` := rand(0..10) fi;   random := proc(x) x = `random/1`() end;  Ans := NULL;  testweights(map(lhs, es));  if type(w,posint) then     ms := allms(w, map(lhs, es)); # allms(n, {X1,X2,...})  elif lhs(w) = 0 then    ms := 1, seq(allms(i, map(lhs, es)), i = 1..rhs(w))  else    ms := seq(allms(i, map(lhs, es)), i = w)  fi;  M := nops([ms]);  userinfo(2, homrels, M, `monomials`, [time() - time0]);  ans := add(_c||i*ms[i], i = 1..nops([ms]));  userinfo(3, homrels, `answer prepared`, [time() - time0]);  aux := NULL;  N := floor(`homrels_redundancy`*M);  for n to N do     rus := map(randomMC, us);    res := traperror((eval@subs)(rus, es)); # lprint(r);    if res = lasterror then # lprint(lasterror)    else aux := aux, (eval@subs)(res, ans);      userinfo(4, homrels, `successful insertion`, n, [time() - time0]);    fi  od;  userinfo(2, homrels, nops({aux}), `equations`, [time() - time0]);  `homrels_system` := aux;  auxs := `union`(op(map(indets, {aux}))) minus {seq(_c||i, i = 1..nops([ms]))};  if auxs <> {} then    userinfo(1, homrels, `WARNING! Indeterminates`, op(auxs), [time() - time0])   fi;  aux := solveMC({aux}, {seq(_c||i, i = 1..nops([ms]))}); # print(aux);  cs := map(lhs, select(evalb, aux));  userinfo(1, homrels, nops(cs), `solutions`, [time() - time0]); # print(cs);  for c1 in cs do    ss := map(proc(c,c1) if c = c1 then c = 1 else c = 0 fi end, cs, c1);    Ans := Ans, factor(subs(aux, ss, ans))  od;end:random_init := proc(`r/range`,`r/sparsity`)  global `r/sparse/1`,`random/1`;  `r/sparse/1` := RandomTools[MersenneTwister][NewGenerator](range = 1..`r/range`):  `random/1` := proc() local i; global `r/range`,`r/sparsity`;    [0$(`r/sparsity`), seq(`r/sparse/1`(), i = `r/range` - `r/sparsity`)][`r/sparse/1`()]   endend:`random/1` := RandomTools[MersenneTwister][NewGenerator](range = 1..1000):`homrels_redundancy` := 2;randomMC := proc(x) x = `random/1`() end:#nops(Rs);##   F i t#fit := proc(as::list)  local aux;  global _t;  if type (as, 'list'(`=`)) then     aux := [seq([lhs(as[i]), rhs(as[i])], i = 1..nops(as))]  else aux := [seq([i, as[i]], i = 1..nops(as))]  fi;  aux := factor(CurveFitting[RationalInterpolation](aux, _t));  if nargs > 1 then    subs(_t = args[2], aux)  else aux   fiend:pfit := proc(as::list)  local aux;  global _t;  if type (as, 'list'(`=`)) then     aux := [seq([lhs(as[i]), rhs(as[i])], i = 1..nops(as))]  else aux := [seq([i, as[i]], i = 1..nops(as))]  fi;  aux := factor(CurveFitting[PolynomialInterpolation](aux, _t));  if nargs > 1 then    subs(_t = args[2], aux)  else aux   fiend:##  S e l e c t   b y   l e n g t h#lengthselect := proc(S,n)  select(proc(s,n) evalb(length(s) < n) end, S, n)end:##  S m a r t   p r i n t i n g#smartprint := proc(p)  if length(p) > smartprintlength then    if type(p, `=`) then       print(lhs(p) = '`A large expression `'('size' = size(rhs(p)), 'length' = length(rhs(p))))    else print('`A large expression `'('size' = size(p), 'length' = length(p)))    fi  else print(p)  fiend:smartprintlength := 1000:`run/put/print` := op(smartprint):##  P o c h h a m m e r   s y m b o l#Pochhammer := proc(x,a,k) mul(x + a*j, j = 0..k-1) end: