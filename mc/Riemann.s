# Riemann.s -- Riemannian Geometry# for Maple 15## (c) 2013 by Michal Marvan##lprint(` `): lprint(` `):print(`Riemannian Geometry on Jets`):print(`for Maple 15`):lprint(` `): lprint(` `):lprint(`Uses linalg`):lprint(`Changes the definition of tensor`):interface (labelling=false):if not assigned(simpl) then simpl := normal fi;protect(sup,sub);unassign('`GR/coordinates`', '`GR/dimension`'): # HB# auxiliarytuples := proc(dim::posint, len::nonnegint)  local i,t;  if len = 0 then [[]]  else [seq(seq([op(t),i], i = 1..dim), t = procname(dim, len - 1))]  fiend:# tensorial typesttype := proc(a)  attributes(a) end:protect(ttype):  `type/ttlist` := list({identical(sub),identical(sup)}):  protect(ttlist):ttypecheck := proc(tt)  if not type(tt,'ttlist') then ERROR(`unexpected ttype`, tt) fiend: invttype := proc(tt)  map(proc(tt)    if tt = 'sup' then 'sub'     elif tt = 'sub' then 'sup'     else ERROR(`unknown type`, tt)     fi  end, tt)end: # tensor (symb, type, {dimension,0}, [fill])  unprotect(tensor):tensor := proc(symb::symbol, tt::ttlist, dim::nonnegint, fill)  local T,i,ii:  T := array(seq(1..dim, i = 1..nops(tt)));  if nargs > 3 then    if type(fill,'procedure') then       for ii in tuples(dim, nops(tt)) do T[op(ii)] := fill(op(ii)) od     elif type(fill,{'list','array'}) then        for ii in tuples(dim, nops(tt)) do T[op(ii)] := fill[op(ii)] od     else lprint(`WARNING! Unrecognized fill parameter`)    fi  fi;  symb := op(T);  setattribute(symb,tt)end:protect(tensor):# zero tensor`index/zero` := proc() 0 end:ZERO := table(zero, []):protect(ZERO):# Kronecker delta`index/kronecker` := proc(indices,table)   local i,j;  if nops(indices) < 2 then ERROR(`Kronecker delta expects exactly two indices`)  else i := indices[1]; j := indices[2]  fi;  if i = j then 1  elif type(i,posint) and type(j,posint) then 0  else table[i,j]   fi end:ID := table(kronecker, []):protect(ID):setattribute(ID,[sup,sub]):  # type tensor`type/tensor` := {matrix,array,identical(ID),table}:`type/vect` := proc(v) evalb(type(v,tensor) and ttype(v) = ['sup']) end:`type/covect` := proc(v) evalb(type(v,tensor) and ttype(v) = ['sub']) end:# get tensor dimensionstensordim := proc(T::tensor)  local dim;  dim := op(2,op(T));  if dim = [] then RETURN() fi;  dim := map(rhs, {dim});  if nops(dim) > 1 then ERROR(`dimension mismatch`, dim)   else op(1,dim)  fiend:# tensor evaluationcompute := proc(symb::symbol, tt::ttlist, ii::list, a)  local R,p,dim,i,m,aux,es,upper,lower,kk,ss;  if nops(ii) <> nops(tt) then ERROR(`number of indices mismatch`) fi;  es := [seq(ii[i]=tt[i], i = 1..nops(ii))]; #print('es' = es);  upper := `compute/1/upper`(es);  lower := `compute/1/lower`(es);  if upper intersect lower <> {} then ERROR(`type of indices mismatch`) fi;  p := expand(a, op(indets(a, function))); # print("Computing", p);  if p = 0 then    if tt = [] then symb := 0; RETURN(symb)    else symb := op(ZERO); setattribute(symb,tt); RETURN(symb)     fi;   elif type(p,`+`) then    aux := seq(op(m,p) = `compute/1/indices`(op(m,p), dim), m = 1..nops(p))  else aux := p = `compute/1/indices`(p, dim)  fi; # `compute/1/indices` assigned value to dim through `compute/1/indices/1`  if dim = 0 then # no tensors except ID    ERROR(`presently cannot handle expressions in ID only`)  fi;  aux := map(    proc(a, upper, lower, dim)      local U,L,S,err,t,ts;      U := `compute/1/upper`(rhs(a));      L := `compute/1/lower`(rhs(a));      S := U intersect L;      err := NULL;      if upper <> U minus S then err := err, upper <> U minus S fi;      if lower <> L minus S then err := err, lower <> L minus S fi;      if err <> NULL then ERROR(`indices position mismatch`, err) fi;      ts := tuples(dim, nops(S));      add((eval@subs)([seq(op(i,S) = t[i], i = 1..nops(S))], lhs(a)), t in ts)    end, [aux], upper, lower, dim);  if tt = [] then # result is scalar    R := table([])  else # result is tensor    R := array(seq(1..dim, i = 1..nops(tt)))  fi;  for kk in tuples(dim,nops(ii)) do    ss := [seq(ii[i] = kk[i], i = 1..nops(kk))];    R[op(kk)] := add((eval@subs)(ss, aux[m]), m = 1..nops(aux));  od;  R := map(simpl@eval, op(R));   if tt = [] then # result is scalar    symb := R[]; RETURN('symb')   else symb := op(R);    setattribute(symb,tt)  fiend:`compute/1/indices` := proc(p, dim) # assigns value to dim through `compute/1/indices/1`  local es;  if type(p,`+`) then ERROR(`this should not happen`)   elif type(p,`*`) then     es := map(`compute/1/indices/1`, [op(p)], dim)  elif type(p,indexed) then es := [`compute/1/indices/1`(p, dim)]   else es := []   fi;  esend:`compute/1/indices/1` := proc(p, dim) # assigns value to dim  local tt,i,ii;  if type(p,numeric) then NULL  elif type(p,indexed) then     if type(dim,integer) then       if nops({tensordim(op(0,p)),0,dim}) > 2 then ERROR(`dimension mismatch`) fi    else dim := tensordim(op(0,p))    fi;     tt := ttype(op(0,p)); ii := [op(p)];    ttypecheck(tt);     seq(ii[i]=tt[i], i = 1..nops(ii))  else NULL  fi end:`compute/1/upper` := proc(es::list(`=`))  local U;  U := map(lhs, select(proc(e) evalb(rhs(e)='sup') end, es));   if nops(U) <> nops({op(U)}) then ERROR(`multiple upper index`) fi;  {op(U)}end:  `compute/1/lower` := proc(es::list(`=`))  local L;  L := map(lhs, select(proc(e) evalb(rhs(e)='sub') end, es));   if nops(L) <> nops({op(L)}) then ERROR(`multiple lower index`) fi;  {op(L)}end:# tensor creationcreate := proc(symb::symbol, T::tensor, U::list({vect,covect}))  local i,Tc,dim,tt,n,j,kk,ordT,aux,Ucs;  dim := {tensordim(T),op(map(tensordim,U))} minus {0};  if nops(dim) > 1 then ERROR(`dimension mismatch`) fi;  dim := op(1,dim);  ordT := nops(ttype(T));  tt := [op(ttype(T)), op(map(op@invttype@ttype, U))]; print(tt);  n := nops(tt);  Tc := array(seq(1..dim, i = 1..n));  for kk in tuples(dim, n) do    Ucs := {seq(U[j][op(ordT+j,kk)], j = 1..nops(U))};    aux := collect(T[op(1..ordT,kk)], Ucs, distributed, simpl);     Tc[op(kk)] := `create/t`(aux, seq(U[j][op(ordT+j,kk)], j = 1..nops(U)))  od;  Tc := map(simpl@eval, op(Tc));    # aux := {op(map(rhs, op(3, op(Tc))))};   # if aux = {0} then symb := op(ZERO)  # else    symb := op(Tc);  # fi;  setattribute(symb,tt)end:`create/t` := proc(a)  local i,b;  b := a;  if type(b, polynom(anything,[args[2..nargs]])) then    for i from 2 to nargs do      b := coeff(b,args[i])    od  else ERROR(`not a tensor`,[args])    fiend:# Lie derivative  Lie := proc(symb::symbol, T::tensor, V::vect, X::list)  local Tc,dim,tt,n,i,j,kk,aux,s;  dim := {tensordim(T),tensordim(V),nops(X)} minus {0};  if nops(dim) > 1 then ERROR(`dimension mismatch`) fi;  dim := op(1,dim);  tt := ttype(T);  n := nops(tt);  Tc := array(seq(1..dim, i = 1..n));  for kk in tuples(dim, n) do    Tc[op(kk)] := add(V[s]*TD(T[op(kk)], X[s]), s = 1..dim);    for j to n do      if tt[j] = 'sup' then Tc[op(kk)] := Tc[op(kk)]          - add(TD(V[op(j,kk)], X[s])*T[op(subsop(j=s,[op(kk)]))], s = 1..dim)      elif tt[j] = 'sub' then Tc[op(kk)] := Tc[op(kk)]          + add(TD(V[s], X[op(j,kk)])*T[op(subsop(j=s,[op(kk)]))], s = 1..dim)      else ERROR(`this should not happen`)      fi        od  od;  Tc := map(simpl@eval, op(Tc));    aux := {op(map(rhs, op(3, op(Tc))))};   if aux = {0} then symb := op(ZERO)  else symb := op(Tc);  fi;  setattribute(symb,[op(tt)])end:# metric(symb, dimension, [fill]);metric := proc(symb::symbol, dim::posint, fill)  local M,i,j:  M := array('symmetric', 1..dim, 1..dim);  if nargs > 2 then     if type (fill, {indexed, listlist, matrix, Matrix}) then # HB      for j to dim do for i to dim do M[i,j] := fill[i,j] od od     else for j to dim do for i to dim do M[i,j] := fill(i,j) od od    fi   fi;  symb := op(M);  setattribute(symb,['sub','sub'])end:`type/metric` := proc(a)   type(a,'matrix'('square')) and ttype(a) = ['sub','sub'] end:# invmetric(symb, dimension, [fill]);invmetric := proc(symb::symbol, dim::posint, fill)  local M,i,j:  M := array('symmetric', 1..dim, 1..dim);  if nargs > 2 then for j to dim do for i to dim do M[i,j] := fill(i,j) od od fi;  symb := op(M);  setattribute(symb,['sup','sup'])end:`type/invmetric` := proc(a)   type(a,'matrix'('square')) and ttype(a) = ['sup','sup'] end:invertmetric := proc(symb::symbol, g::metric)  symb := map(simpl, linalg[inverse](g));  setattribute(symb,['sup','sup'])end:# submetricsubmetric := proc(symb::symbol, g::metric, ii::{list,range})  symb := linalg[submatrix](g, ii, ii);  setattribute(symb,[sub,sub])end:# transform metrictransfmetric := proc(g::matrix, xs, G::matrix, Xs)  local n,i,j,k,l;  n := {nops(xs),rowdim(g),coldim(g),nops(Xs),rowdim(G),coldim(G)};  if nops(n) = 1 then n := op(1,n) else print(n); ERROR(`wrong dimensions`) fi;  seq(seq(    add(add(G[k,l]*TD(Xs[k],xs[i])*TD(Xs[l],xs[j]) - g[i,j], k = 1..n), l = 1..n),   i = 1..n), j = 1..n)end:# christoffel(posint, xlist, fill) christoffel := proc(symb::symbol, dim::posint, fill)  local Ch,i,j,k:  Ch := array(1..dim, 1..dim, 1..dim);  if nargs > 2 then for i to dim do for j to dim do for k to dim do    Ch[k,i,j] := fill(k,i,j)   od od od fi;  symb := op(Ch);  setattribute(symb,['sup','sub','sub'])end:# LeviCivitaLeviCivita := proc(symb::symbol, g::metric, ig::invmetric, X::list)  local Ch,dim,i,j,k,s;  dim := tensordim(g);  Ch := array(1..dim, 1..dim, 1..dim);  for k to dim do     for i to dim do       for j from i to dim do        Ch[k,i,j] := simpl((1/2)*add(ig[k,s]*eval(TD(g[s,i],X[j])          + TD(g[s,j],X[i]) - TD(g[i,j],X[s])), s=1..dim));         Ch[k,j,i] := Ch[k,i,j]       od    od   od;  symb := op(Ch);   setattribute(symb,['sup','sub','sub']) end:# covariant derivative  cderive := proc(symb::symbol, T::tensor, ch::array, X::list)  local Tc,dim,tt,n,i,j,kk,aux,s;  dim := {tensordim(T),tensordim(ch),nops(X)} minus {0};  if nops(dim) > 1 then ERROR(`dimension mismatch`) fi;  dim := op(1,dim);  tt := ttype(T);  n := nops(tt);  Tc := array(seq(1..dim, i = 1..n+1));  for kk in tuples(dim, n+1) do    Tc[op(kk)] := TD(T[op(1..n,kk)], X[op(n+1,kk)]);    for j to n do      if tt[j] = 'sup' then Tc[op(kk)] := Tc[op(kk)]          + add(ch[op(j,kk),s,op(n+1,kk)]*T[op(subsop(j=s,[op(1..n,kk)]))], s = 1..dim)      elif tt[j] = 'sub' then Tc[op(kk)] := Tc[op(kk)]          - add(ch[s,op(j,kk),op(n+1,kk)]*T[op(subsop(j=s,[op(1..n,kk)]))], s = 1..dim)      else ERROR(`this should not happen`)      fi        od  od;  Tc := map(simpl@eval, op(Tc));    symb := op(Tc);  setattribute(symb,[op(tt),'sub'])end:  # riemann(christoffel);Riemann := proc(symb::symbol, ch::array, X::list) # MTW  local R,dim,i,j,k,l,s,aux;   dim := tensordim(ch);  R := array(1..dim,1..dim,1..dim,1..dim);  for l to dim do     for k to dim do       for i to dim do         for j to dim do          R[i,j,k,l] := TD(ch[i,j,l],X[k]) - TD(ch[i,j,k],X[l])             + add(ch[s,j,l]*ch[i,s,k] - ch[s,j,k]*ch[i,s,l], s = 1..dim)         od      od     od  od;  R := map(simpl@eval, op(R));    symb := op(R);  setattribute(symb,['sup','sub','sub','sub']) end:# gymgym := proc(symb::symbol, tt::ttlist, T::tensor, g::metric, ig::invmetric)  local i,Ta,Tb,dim,ttT,n,m,kk,aux,s;  dim := {tensordim(T),tensordim(g),tensordim(ig)};  if nops(dim) > 1 then ERROR(`dimension mismatch`) fi;  dim := op(1,dim);  ttT := ttype(T);  n := {nops(tt),nops(ttT)};  if nops(n) > 1 then ERROR(`order mismatch`) fi;  n := op(1,n);  Ta := copy(T);  Tb := array(seq(1..dim, i = 1..n));  for m to n do    if tt[m] = 'sub' and ttT[m] = 'sup' then       for kk in tuples(dim, n) do        Tb[op(kk)] := add(g[op(m,kk),s]*Ta[op(subsop(m=s,[op(kk)]))], s = 1..dim)      od;      Ta := copy(Tb)    elif tt[m] = 'sup' and ttT[m] = 'sub' then       for kk in tuples(dim, n) do        Tb[op(kk)] := add(ig[op(m,kk),s]*Ta[op(subsop(m=s,[op(kk)]))], s = 1..dim)      od;      Ta := copy(Tb)    fi  od;  Ta := map(simpl@eval, op(Ta));   symb := op(Ta);  setattribute(symb,[op(tt)])end:# Einstein equationsEinstTensor := proc(symb, tt::ttlist, g::metric, ig::invmetric, X::list, lambda) # lambda is optional  local i,j,k,ch,Rie,ric,sc,einst,ans;  LeviCivita(ch, g, ig, X);  lprint("Christoffel symbols computed");   Riemann(Rie, ch, X);  lprint("Riemann tensor computed");   compute(ric, [sub,sub], [i,j], Rie[k,i,k,j]);  lprint("Ricci tensor computed");   compute(sc, [], [], ric[i,j]*ig[i,j]);  lprint("Scalar curvature computed");   if nargs < 6 then compute(einst, [sub,sub], [i,j], ric[i,j] - (1/2)*sc*g[i,j]);    lprint("Einstein tensor computed");   else lprint("Cosmological constant" = lambda);    compute(einst, [sub,sub], [i,j], ric[i,j] - (1/2)*sc*g[i,j] + lambda*g[i,j]);    lprint("Einstein tensor computed");   fi;  gym(ans, tt, einst, g, ig);  lprint("Indices raised and/or lowered");   setattribute(symb,[op(tt)]);  symb := op(ans)end:# epsilon (not an invariant)`index/parity` := proc(inds,table)   local i,j,n,es;  n := nops(inds);  if nops({op(inds)}) < n then 0  elif type(inds,list(posint)) then     es := [seq(seq(inds[i]=inds[j], j = i+1..n), i = 1..n)];    (-1)^nops(select(proc(e) evalb(lhs(e) > rhs(e)) end, es))      else table[op(inds)]   fi end:for `eps/dim` from 2 to 10 do  subeps||`eps/dim` := array(parity, (1..`eps/dim`)$`eps/dim`);  supeps||`eps/dim` := array(parity, (1..`eps/dim`)$`eps/dim`);  setattribute(subeps||`eps/dim`,[sub$`eps/dim`]);  setattribute(supeps||`eps/dim`,[sup$`eps/dim`])end:# volume formvolumeform := proc(symb::symbol, g::metric, sign)   local detg;  if nargs > 2 then     if sign = 'abs' then      detg := sqrt(abs(linalg:-det(g)))    elif sign = 'positive' then       detg := sqrt(linalg:-det(g))    elif sign = 'negative' then       detg := sqrt(-linalg:-det(g))    else ERROR(`unrecognized sign`)    fi  else detg := sqrt(abs(linalg:-det(g)))  fi;  symb := map(eval, array(parity, (1..tensordim(g))$tensordim(g)), [1 = detg, -1 = -detg]);  setattribute(symb,[sub$tensordim(g)])end:# Weyl tensor from riemann tensorweyl := proc(symb::symbol, Rie::tensor, g::metric, ig::invmetric)  local i,j,k,l,rie,ric,sc,gr,gg,n,ans;  gym(rie, [sub,sub,sub,sub], Rie, g, ig);  lprint("indices lowered");   compute(ric, [sub,sub], [i,j], Rie[k,i,k,j]);  lprint("Ricci tensor computed");   compute(sc, [], [], ric[i,j]*ig[i,j]);  lprint("Scalar curvature computed");   compute(gr, [sub,sub,sub,sub], [i,j,k,l],    g[i,k]*ric[l,j] - g[i,l]*ric[k,j] - g[j,k]*ric[l,i] + g[j,l]*ric[k,i]);  compute(gg, [sub,sub,sub,sub], [i,j,k,l], g[i,k]*g[l,j] - g[i,l]*g[k,j]);  n := tensordim(Rie);  compute(symb, [sub,sub,sub,sub], [i,j,k,l], rie[i,j,k,l] - gr[i,j,k,l]/(n - 2)    + sc*gg[i,j,k,l]/(n - 1)/(n - 2));  symbend:# differentialdif := proc(symb::symbol, f, X::list)   symb := array(1..nops(X), map2(TD, f, X));  setattribute(symb,[sub])end:# gradientgradient := proc(symb::symbol, f, ig::invmetric, X::list)   local df,i,j;  dif(df, f, X);  compute(symb, [sup], [i], ig[i,j]*df[j])end:gradient2 := proc(symb::symbol, f1, f2, ig::invmetric, X::list)   local df1,df2,i,j;  dif(df1, f1, X);  dif(df2, f2, X);  compute(symb, [], [], ig[i,j]*df1[i]*df2[j])end:# Hessian  Hess := proc(symb::symbol, f::scalar, ch::array, X::list)  local i,j,k;  compute(symb, [sub,sub], [i,j], TD(f,X[i]*X[j]) - ch[k,i,j]*TD(f,X[k]))end:# dot productdotproduct := proc(X,Y)  local N,i,j,g,X1,Y1,aux;  global `GR/dimension`,`GR/metric`;  if nargs < 3 then g := op(`GR/metric`) else g := op(args[3]) fi;  N := `GR/dimension`;  aux := 0;  X1 := convert(X,'line');  Y1 := convert(Y,'line');  for i to N do    for j to N do       aux := aux + X1[i]*g[i,j]*Y1[j]    od  od;  auxend:orth := proc(X)  local N,i,j,g,ans;  global `GR/dimension`,`GR/metric`;  if nargs < 2 then g := op(`GR/metric`) else g := op(args[2]) fi;  N := `GR/dimension`;  ans := array(1..N);  for j to N do     ans[j] := convert([seq(g[i,j]*X[i], i = 1..N)],`+`);   od;  op(ans) end:orthproj := proc(U,X)  local N,i,aux;  global `GR/dimension`,`GR/metric`;# if nargs < 3 then g := op(`GR/metric`) else g := op(args[3]) fi;  N := `GR/dimension`;  aux := dotproduct(X,U)/dotproduct(X,X);  array(1..N,[seq(aux*X[i], i = 1..N)])end:orthcoproj := proc(U,X)  global `GR/dimension`,`GR/metric`;# if nargs < 3 then g := op(`GR/metric`) else g := op(args[3]) fi;  evalm(convert(U,'line') - orthproj(U,X))end:d1 := proc(h)  local N,X,i,j,ans;  global `GR/coordinates`,`GR/dimension`;  N := `GR/dimension`;  X := `GR/coordinates`;  ans := matrix(N,N,0);  for i to N do    for j from i + 1 to N do       ans[i,j] := TD(h[j],X[i]) - TD(h[i],X[j]);      ans[j,i] := -ans[i,j]     od  od;  op(ans) end:`convert/line` := proc(h)  local N,i;  global `GR/dimension`;  N := `GR/dimension`;  if type(h,'matrix') then    if rowdim = 1 then      array(1..N,[seq(h[1,i], i = 1..N)])    elif coldim = 1 then      array(1..N,[seq(h[i,1], i = 1..N)])    else ERROR(`wrong argument`)    fi  else    array(1..N,[seq(h[i], i = 1..N)])  fiend:`convert/row` := proc(h)  local N,i;  global `GR/dimension`;  N := `GR/dimension`;  matrix(1,N,[seq(h[i], i = 1..N)])end:`convert/column` := proc(h)  local N,i;  global `GR/dimension`;  N := `GR/dimension`;  matrix(N,1,[seq(h[i], i = 1..N)])end:`convert/vectorfield` := proc(h)  local N,X,i;  global `GR/coordinates`,`GR/dimension`;  N := `GR/dimension`;  X := `GR/coordinates`;  convert([seq(h[i]*pd[X[i]], i = 1..N)],`+`)end:# https://en.wikipedia.org/wiki/Einstein–Hilbert_action